<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RegExp</title>
</head>
<body>
    <!-- 01RegExp创建 -->
    <script>
        //1.创建方式一：/正则表达式/
        var re1 = /ABC\-001/;
        console.log(re1);// /ABC\-001/
        //2.创建方式二：new RegExp('正则表达式')
        //注意：因为字符串的转义问题，字符串的两个\\实际上是一个\
        var re1 = new RegExp("ABC\\-001");
        console.log(re1);// /ABC\-001/s

        //3.匹配字符串test()
        var re1 = /^\d{3}\-\d{3,8}$/;
        re1 = new RegExp("^\\d{3}\\-\\d{3,8}$");
        console.log(re1);// /^\d{3}\-\d{3,8}$/
        console.log(re1.test("032-1234"));//true
        console.log(re1.test("023-12345678x"));//false

        //4.切分字符串 split
        //join与split 相反的操作
        var arr = [1,2,3,4];
        var str = arr.join('-');
        console.log(str);
        var arr1 = str.split('-');
        console.log(arr1);

        //split的正则应用
        /*
            1.普通split的缺陷：无法连续匹配空格，正则可以 
         */
        var str = "a b   c";
        console.log(str.split(' '));//["a", "b", "", "", "c"]
        console.log(str.split(/\s+/));//["a", "b", "c"]
        var str = "a b,  c";
        console.log(str.split(/[\s,]+/));//["a", "b", "c"]
        var str = "a b,; ; c";
        console.log(str.split(/[\s,;]+/));//["a", "b", "c"]

        //5.分组 exec
        /* 
            1.在RegExp对象上用exec()方法提取出子串来。
                -exec()方法在匹配成功后，会返回一个Array，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。
                -exec()方法在匹配失败时返回null。
            2.
         */
        var re = /^(\d{3})-(\d{3,8})$/;
        //["010-12345", "010", "12345", index: 0, input: "010-12345", groups: undefined]
        console.log(re.exec('010-12345'));
        console.log(re.exec('010 12345'));// null
        //匹配时间
        var re = /^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/
        // ["9:05:30", "9", "05", "30", index: 0, input: "9:05:30", groups: undefined]
        console.log(re.exec('9:05:30'));
        //匹配日期
        //这里的4-31,2-30属于非法日期，但仍会匹配上
        var re = /^(0[1-9]|1[0-2]|[0-9])-(0[1-9]|1[0-9]|2[0-9]|3[0-1]|[0-9])$/;
        console.log(re.exec("4-31"));//["4-31", "4", "31", index: 0, input: "4-31", groups: undefined]
        console.log(re.exec("2-30"));

        //6.贪婪匹配（JavaScript默认为贪婪匹配）
        //贪婪匹配，也就是匹配尽可能多的字符。
        var re = /^(\d+)(0*)$/;
        // 由于\d+采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了。
        console.log(re.exec('102300'));// ['102300', '102300', '']
        //采用非贪婪匹配（也就是尽可能少匹配）
        var re = /^(\d+?)(0*)$/;
        console.log(re.exec('102300'));
    </script>
</body>
</html>